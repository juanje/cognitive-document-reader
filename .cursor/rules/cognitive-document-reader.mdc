---
description: Main rules for Cognitive Document Reader project - Python library for human-like document understanding
globs: ["**/*.py", "**/*.md", "**/*.toml", "**/*.yaml", "**/*.yml"]
alwaysApply: true
---

# Cognitive Document Reader - Main Project Rules

## üéØ Project Overview

You are working on **Cognitive Document Reader**, a Python library that simulates human-like document reading through progressive understanding and hierarchical synthesis. This project focuses on high-quality summaries for human reading and enriched metadata for AI projects.

## üîß Technology Stack

### Core Technologies
- **Python Version:** 3.10+ (use modern Python features)
- **Dependency Management:** `uv` (replaces Poetry, pip, venv)
- **Code Quality:** `ruff` for linting and formatting (replaces black, isort, flake8)
- **Type Checking:** `mypy` with strict type annotations
- **Testing:** `pytest` with `pytest-asyncio`
- **Documentation:** Google-style docstrings
- **Async Programming:** Prefer `async`/`await` for I/O operations

### Domain-Specific Libraries
- **Document Parsing:** `docling` for universal document processing
- **LLM Integration:** Focus on Ollama integration, consider LangChain for Phase 2+
- **Data Validation:** `pydantic` v2+ for all configuration and data models
- **Language Detection:** `langdetect`
- **HTTP Client:** `aiohttp` for async HTTP operations
- **CLI Framework:** `click`

## üìã Mandatory Code Standards

### 1. Type Annotations (CRITICAL)
- **ALL functions, methods, and class members MUST have type annotations**
- Use the most specific types possible
- Import from `typing` module when needed
- Use `from __future__ import annotations` for forward references

### 2. Documentation (CRITICAL)
- **ALL public functions, methods, and classes MUST have Google-style docstrings**
- Include purpose, parameters, return values, and exceptions
- Add usage examples for complex functions

### 3. Exception Handling (CRITICAL)
- Use specific exception types, never bare `except:`
- Create custom exception classes for domain-specific errors
- Provide informative error messages without exposing sensitive data

## üèóÔ∏è Architecture Principles

### 1. Single Responsibility Principle
- Each module/class should have one clear responsibility
- Keep functions focused and small (prefer <50 lines)
- Extract complex logic into separate functions

### 2. Composition Over Inheritance
- Favor composition and dependency injection
- Use protocols/interfaces for abstraction
- Avoid deep inheritance hierarchies

### 3. Explicit Over Implicit
- Be explicit about dependencies and configurations
- Avoid magic values or implicit behaviors
- Use clear, descriptive variable and function names

### 4. Async-First Design
- Use `async`/`await` for all I/O operations
- Design APIs to be async-compatible from the start
- Use `asyncio` patterns correctly

## ‚öôÔ∏è Configuration Management

### 1. Environment-Driven Configuration
- ALL configuration via environment variables
- No hardcoded values in code
- Use Pydantic models for configuration validation
- Support `.env` files for development

### 2. Development-Friendly Features
- Always include dry-run modes for AI agent development
- Provide mock responses for testing
- Include validation-only modes

## üß™ Testing Standards

### 1. Test Coverage Goals
- Target: 90% code coverage minimum
- Focus on critical paths and error handling
- Test both success and failure scenarios

### 2. Test Organization
- Use `pytest` with async support
- Create fixtures for common test data
- Mock external dependencies (LLM calls, file I/O)

## üöÄ Development Workflow

### 1. Conventional Commits
Always use conventional commit format:
```bash
feat: add progressive reading functionality
fix: resolve memory leak in document parser
docs: update README with CLI examples
refactor: extract prompt management to separate module
test: add unit tests for hierarchical synthesis
```

### 2. Git Staging Best Practices

**NEVER use `git add .` for commits.** Always add files explicitly for atomic, controlled commits:

```bash
# ‚úÖ CORRECT: Add specific files
git add src/cognitive_reader/models/config.py
git add tests/unit/test_config.py
git commit -m "feat: add dual model configuration system"

# ‚úÖ CORRECT: Add specific changes within a file
git add -p src/cognitive_reader/llm/client.py  # Choose which changes to stage
git commit -m "fix: update model selection logic"

# ‚úÖ CORRECT: Add multiple related files
git add src/cognitive_reader/cli/main.py src/cognitive_reader/models/config.py
git commit -m "feat: add --fast-mode CLI flag with config support"

# ‚ùå WRONG: Blind staging
git add .  # Stages everything without review
```

**Benefits of explicit staging:**
- ‚úÖ **Atomic commits**: Each commit contains only related changes
- ‚úÖ **Code review**: Review each change before staging
- ‚úÖ **Clean history**: Easier to track, revert, and understand changes
- ‚úÖ **Professional workflow**: Industry standard for production code

**Workflow:**
1. `git status` - See what changed
2. `git diff` - Review changes before staging
3. `git add specific_file.py` - Stage only what belongs in this commit
4. `git add -p other_file.py` - Stage partial changes if needed
5. `git commit -m "type: descriptive message"`

### 3. Feature-Complete Commits Strategy

**CRITICAL: Each feature should be implemented as a complete, atomic commit that includes ALL related changes.**

When implementing multi-feature functionality, organize commits by **feature completeness**, not by **technical layer**:

```bash
# ‚úÖ CORRECT: Feature-complete commits
feat: implement partial results saving
  - Config: save_partial_results + partial_results_dir fields
  - Code: _save_partial_result method + integration in progressive_reader
  - CLI: --save-partials + --partials-dir options
  - Tests: comprehensive test coverage for partial saving
  - Docs: user documentation and examples

feat: implement section depth limiting  
  - Config: max_section_depth field + environment variable
  - Code: _filter_by_depth method + _apply_section_filters integration
  - CLI: --max-depth option
  - Tests: depth filtering test coverage
  - Docs: depth limiting documentation + examples

feat: implement section count limiting
  - Config: max_sections field + environment variable
  - Code: section count limiting in _apply_section_filters
  - CLI: --max-sections option  
  - Tests: section count limiting tests
  - Docs: count limiting documentation + examples

# ‚ùå WRONG: Technical layer commits
feat: add all config fields for development features
feat: implement all filtering logic
feat: add all CLI options
test: add all tests for development features
docs: document all development features
```

**Benefits of Feature-Complete Commits:**
- ‚úÖ **Atomic features**: Each commit represents one complete, working feature
- ‚úÖ **Easy reversion**: Can revert specific features without breaking others
- ‚úÖ **Clear history**: Git log shows feature progression, not technical layers
- ‚úÖ **Better reviews**: Each commit can be reviewed as a complete functional unit
- ‚úÖ **Release management**: Easy to cherry-pick or exclude specific features

**Implementation Workflow:**
1. **Plan features**: Identify distinct, independent features to implement
2. **Implement completely**: Code + tests + docs for ONE feature at a time
3. **Commit atomically**: One commit per complete feature
4. **Verify independence**: Each commit should work independently

### 4. Development Commands
```bash
# Setup development environment
uv sync

# Code quality checks
uv run ruff check .
uv run ruff format .
uv run mypy src/

# Testing
uv run pytest
uv run pytest --cov=cognitive_reader --cov-report=html

# CLI testing
uv run cognitive-reader --dry-run document.md
```

## ü§ñ AI Agent Development Support

### Always Include These Features
- `dry_run` mode for cost-free testing
- `mock_responses` for deterministic testing
- `validate_config_only` for quick validation
- Clear success/failure indicators

## üìÅ File Organization

### Expected Directory Structure
```
src/cognitive_reader/
‚îú‚îÄ‚îÄ __init__.py              # Public API exports
‚îú‚îÄ‚îÄ core/                    # Core reading logic
‚îú‚îÄ‚îÄ parsers/                 # Document parsing
‚îú‚îÄ‚îÄ llm/                     # LLM integration
‚îú‚îÄ‚îÄ models/                  # Pydantic data models
‚îú‚îÄ‚îÄ utils/                   # Utility functions
‚îî‚îÄ‚îÄ cli/                     # Command-line interface
```

**Remember: This is a professional-grade library focused on cognitive document reading. Prioritize code quality, type safety, and user experience. Every function should be well-documented, properly typed, and thoroughly tested.**