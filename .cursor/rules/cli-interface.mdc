---
description: CLI interface rules for user-friendly command line experience
globs: ["src/cognitive_reader/cli/**/*.py", "**/test*cli*.py"]
alwaysApply: false
---

# CLI Interface Rules

## 🖥️ CLI Philosophy

Focus on **user experience, clear error messages, and developer-friendly features**.

## 🎯 CLI Design Principles

### 1. User-Centric Design
- Clear, intuitive command structure
- Helpful error messages with actionable advice
- Progressive disclosure (basic usage simple, advanced features available)
- Consistent behavior across all commands

### 2. Developer-Friendly Features
- Dry-run modes for testing without costs
- Verbose modes for debugging
- Multiple output formats for integration
- Validation modes for configuration checking

### 3. Professional CLI Standards
- Follow UNIX philosophy principles
- Support standard input/output patterns
- Proper exit codes for scripting
- Comprehensive help documentation

## 📋 Required CLI Structure

### Main Command with Click
```python
import click
import asyncio
from cognitive_reader import CognitiveReader
from cognitive_reader.models import ReadingConfig

@click.group(invoke_without_command=True)
@click.option('--version', is_flag=True, help='Show version and exit')
@click.pass_context
def cli(ctx: click.Context, version: bool) -> None:
    """Cognitive Document Reader - Human-like document understanding.
    
    Process documents with progressive reading and hierarchical synthesis
    to create high-quality summaries and structured knowledge extraction.
    """
    if version:
        from cognitive_reader._version import __version__
        click.echo(f"cognitive-reader {__version__}")
        ctx.exit(0)
```

### Read Command Pattern
```python
@cli.command()
@click.argument('input_file', type=click.Path(exists=True, readable=True), required=False)
@click.option('--output', '-o', 
              type=click.Choice(['markdown', 'json', 'summary'], case_sensitive=False),
              default='markdown', help='Output format')
@click.option('--dry-run', is_flag=True, help='Simulate processing without LLM calls')
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
def read(input_file, output, dry_run, verbose) -> None:
    """Read and analyze a document using cognitive reading."""
    try:
        asyncio.run(_read_document(input_file, output, dry_run, verbose))
    except KeyboardInterrupt:
        click.echo("\nOperation cancelled by user.", err=True)
        sys.exit(130)  # Standard exit code for SIGINT
```

## 🎨 Output Formatting Requirements

### Multiple Output Formats
```python
def _format_output(knowledge, format_type: str) -> str:
    """Format knowledge output in specified format."""
    if format_type == 'json':
        return json.dumps(knowledge.model_dump(), indent=2, ensure_ascii=False)
    elif format_type == 'summary':
        return knowledge.document_summary
    elif format_type == 'markdown':
        return _format_markdown_output(knowledge)
```

### Colored Output with Status
```python
def print_success(message: str) -> None:
    """Print success message with green color."""
    click.echo(click.style(f"✓ {message}", fg='green'))

def print_warning(message: str) -> None:
    """Print warning message with yellow color."""
    click.echo(click.style(f"⚠️  {message}", fg='yellow'), err=True)

def print_error(message: str) -> None:
    """Print error message with red color."""
    click.echo(click.style(f"✗ {message}", fg='red'), err=True)
```

## 🔧 Required Commands

### Configuration Command
```python
@cli.command()
@click.option('--format', '-f',
              type=click.Choice(['table', 'json'], case_sensitive=False),
              default='table', help='Output format for configuration')
def config(format_type: str) -> None:
    """Show current configuration settings."""
    try:
        config = ReadingConfig.from_env()
        if format_type == 'json':
            click.echo(json.dumps(config.model_dump(), indent=2))
        else:
            _display_config_table(config)
    except Exception as e:
        click.echo(f"Error loading configuration: {e}", err=True)
        sys.exit(1)
```

### Validation Command (MANDATORY)
```python
@cli.command()
@click.option('--fix', is_flag=True, help='Suggest fixes for configuration issues')
def validate(fix: bool) -> None:
    """Validate current configuration and LLM connectivity."""
    try:
        config = ReadingConfig.from_env()
        click.echo("✓ Configuration loaded successfully")
        
        # Test LLM connectivity without expensive calls
        async def test_llm():
            reader = CognitiveReader(config)
            return await reader.validate_configuration()
        
        is_llm_valid = asyncio.run(test_llm())
        
        if is_llm_valid:
            click.echo("✓ LLM connection validated")
            click.echo("🎉 All validation checks passed!")
        else:
            click.echo("✗ LLM connection failed", err=True)
            if fix:
                _suggest_llm_fixes(config)
            sys.exit(1)
    except Exception as e:
        click.echo(f"✗ Validation failed: {e}", err=True)
        sys.exit(1)
```

## 🚨 Error Handling Requirements

### Custom CLI Errors
```python
class CLIError(click.ClickException):
    """Custom CLI error with helpful messages."""
    
    def show(self, file=None):
        click.echo(f"Error: {self.message}", err=True, file=file)
        click.echo("", err=True, file=file)
        click.echo("💡 For help, run: cognitive-reader --help", err=True, file=file)
```

### Input Validation
```python
def validate_input_file(file_path: str) -> None:
    """Validate input file with helpful error messages."""
    if not Path(file_path).exists():
        raise CLIError(f"File not found: {file_path}")
    
    if not Path(file_path).is_file():
        raise CLIError(f"Path is not a file: {file_path}")
    
    # Check file size (warn for very large files)
    file_size = Path(file_path).stat().st_size
    if file_size > 10 * 1024 * 1024:  # 10MB
        click.echo(f"⚠️  Large file detected ({file_size / (1024*1024):.1f}MB). Processing may take longer.", err=True)
```

## 📊 Progress and Feedback

### Progress Indicators
```python
def show_progress(items, description="Processing"):
    """Show progress bar for long operations."""
    with click.progressbar(items, label=description) as bar:
        for item in bar:
            yield item
```

### Verbose Mode Support
```python
def setup_logging(verbose: bool = False, quiet: bool = False) -> None:
    """Setup logging based on verbosity flags."""
    if quiet:
        level = logging.ERROR
    elif verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO
    
    logging.basicConfig(level=level, format='%(levelname)s: %(message)s')
```

## ✅ Required CLI Features

1. **Always support stdin/stdout** for Unix pipe compatibility
2. **Multiple output formats** (JSON, Markdown, Summary)
3. **Dry-run mode** for cost-free testing
4. **Configuration validation** command
5. **Helpful error messages** with suggestions
6. **Progress indicators** for long operations
7. **Proper exit codes** for scripting
8. **Version command** with semantic versioning

**Remember: The CLI is often the first experience users have with the tool. Make it intuitive, helpful, and robust. Provide clear error messages, support common workflows, and always include dry-run modes for safe testing.**